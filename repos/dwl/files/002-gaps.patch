Personal gaps patch

diff --git a/config.def.h b/config.def.h
index 190b0da..98148a6 100644
--- a/config.def.h
+++ b/config.def.h
@@ -6,6 +6,12 @@ static const float rootcolor[]      = {0.3, 0.3, 0.3, 1.0};
 static const float bordercolor[]    = {0.5, 0.5, 0.5, 1.0};
 static const float focuscolor[]     = {1.0, 0.0, 0.0, 1.0};
 
+static struct Gap const gap = {
+   .outer = 10,
+   .inner = 10,
+   .smart = 1,
+};
+
 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
 
diff --git a/dwl.c b/dwl.c
index b09fc6f..3c44814 100644
--- a/dwl.c
+++ b/dwl.c
@@ -165,6 +165,12 @@ typedef struct {
 	void (*arrange)(Monitor *);
 } Layout;
 
+struct Gap {
+   unsigned int inner;
+   unsigned int outer;
+   int smart; /* whether it should show gap if there's only one window in the tag */
+};
+
 struct Monitor {
 	struct wl_list link;
 	struct wlr_output *wlr_output;
@@ -181,6 +187,7 @@ struct Monitor {
 	double mfact;
 	int nmaster;
 	int un_map; /* If a map/unmap happened on this monitor, then this should be true */
+   struct Gap gap;
 };
 
 typedef struct {
@@ -890,6 +897,10 @@ createmon(struct wl_listener *listener, void *data)
 		}
 	}
 
+   m->gap.inner = gap.inner;
+   m->gap.outer = gap.outer;
+   m->gap.smart = gap.smart;
+
 	/* The mode is a tuple of (width, height, refresh rate), and each
 	 * monitor supports only a specific set of modes. We just pick the
 	 * monitor's preferred mode; a more sophisticated compositor would let
@@ -2129,7 +2140,7 @@ tagmon(const Arg *arg)
 void
 tile(Monitor *m)
 {
-	unsigned int i, n = 0, h, mw, my, ty;
+	unsigned int i, n = 0, h, r, mw, my, ty, prev_gap_outer = 0;
 	Client *c;
 
 	wl_list_for_each(c, &clients, link)
@@ -2138,25 +2149,37 @@ tile(Monitor *m)
 	if (n == 0)
 		return;
 
+   if (m->gap.smart && m->gap.outer != 0 && n == 1) {
+       prev_gap_outer = m->gap.outer;
+       m->gap.outer = 0;
+   }
+
 	if (n > m->nmaster)
 		mw = m->nmaster ? m->w.width * m->mfact : 0;
 	else
-		mw = m->w.width;
-	i = my = ty = 0;
+		mw = m->w.width - 2 * m->gap.outer;
+
+   i = 0;
+   my = ty = m->gap.outer;
 	wl_list_for_each(c, &clients, link) {
 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
 		if (i < m->nmaster) {
-			h = (m->w.height - my) / (MIN(n, m->nmaster) - i);
-			resize(c, m->w.x, m->w.y + my, mw, h, 0);
-			my += c->geom.height;
+           r = MIN(n, m->nmaster) - i;
+			h = (m->w.height - my - m->gap.outer - m->gap.inner * (r - 1)) / r;
+			resize(c, m->w.x + m->gap.outer, m->w.y + my, mw, h, 0);
+			my += c->geom.height + m->gap.inner;
 		} else {
-			h = (m->w.height - ty) / (n - i);
-			resize(c, m->w.x + mw, m->w.y + ty, m->w.width - mw, h, 0);
-			ty += c->geom.height;
+           r = n - i;
+			h = (m->w.height - ty - m->gap.outer - m->gap.inner * (r - 1)) / r;
+			resize(c, m->w.x + mw + m->gap.outer + (m->nmaster == 0 ? 0 : m->gap.inner), m->w.y + ty, m->w.width - mw - 2 * m->gap.outer - (m->nmaster == 0 ? 0 : m->gap.inner), h, 0);
+			ty += c->geom.height + m->gap.inner;
 		}
 		i++;
 	}
+
+    if (m->gap.smart && n == 1)
+        m->gap.outer = prev_gap_outer;
 }
 
 void
